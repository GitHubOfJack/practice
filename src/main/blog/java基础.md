1 位运算

​	![位运算](D:\personWorkspace\practice\src\main\blog\位运算.png)

​	补码

​	在计算机系统中，数值一律用补码来表示和存储，其中最高位表示符号位，1表示负数，0表示正数。

- 正数的补码是原码自身。

- 负数补码是通过原码计算得到，计算过程为：符号位不变，其余位按照原码取反加1

  -100的原码：10000000 00000000 00000000 01100100
  符号位保持不变，取反：11111111 11111111 11111111 10011011
  加1后，-100补码为：11111111 11111111 11111111 10011100

- ## 正数右移(100右移4位为例)

- | 操作    | 二进制                              | 对应十进制 |
  | ------- | ----------------------------------- | ---------- |
  | 补码    | 00000000 00000000 00000000 01100100 | 100        |
  | 右移4位 | 00000000 00000000 00000000 00000110 | 6          |
  | 源码    | 00000000 00000000 00000000 00000110 | 6          |

## 负数右移(-100右移4位为例)

| 操作                 | 二进制                              | 对应十进制 |
| -------------------- | ----------------------------------- | ---------- |
| 原码                 | 10000000 00000000 00000000 01100100 | -100       |
| 转换为补码           | 11111111 11111111 11111111 10011100 | -100       |
| 右移4位，高位补1     | 11111111 11111111 11111111 11111001 |            |
| 保留符号位，按位取反 | 10000000 00000000 00000000 00000110 |            |
| 加1后转为源码        | 10000000 00000000 00000000 00000111 | -7         |

## 无符号右移(-100右移4位为例)

| 操作             | 二进制                              | 对应十进制 |
| ---------------- | ----------------------------------- | ---------- |
| 原码             | 10000000 00000000 00000000 01100100 | -100       |
| 转换为补码       | 11111111 11111111 11111111 10011100 | -100       |
| 右移4位，高位补0 | 00001111 11111111 11111111 11111001 |            |
| 转为原码         | 00001111 11111111 11111111 11111001 | 268435449  |

常用操作:

​	判定奇偶：a&1 = 0 偶数  a&1 = 1 奇数

​	交换两个变量： a ^=b  b^=a a^=b

​	取模运算：a % 2^n等价于 a & (2^n - 1)

​	乘法运算：a * (2^n) 等价于 a << n

​	除法运算：a / (2^n) 等价于 a>> n

​	对称加密：采用^操作，原理^同一个值就会得到原值 例如a=a^b^b

2 基本数据类型&包装类

​	bit(1位) byte(字节-8位) char(2个字节-16位) short(2个字节-16位) int(4个字节-32位) long(8个字节-64位) float(4个字节-32位) double(8个字节-64位)

```
* 构造方法有如下几种
* Integer a = 1;  字节码底层是Integer.valueOf(1)实现的
* Integer b = new Integer(1);
* Integer.valueOf(1)  -127到128 会先查看缓存中是否有值,如果没有值new Integer(i)
*
* Integer.equals比较的是两个值是否相等
* == 比较的是内存地址
*
* 如果一个Integer对象和int值做对比,则先调用Integer.intValue获取Integer的值，然后两个int值做对比
```

3 String、StringBuilder、StringBuffer、threadlocal



4 ArrayList\LinkedList\HashMap\TreeMap\ConcurrentHashMap\CopyOnWriteArrayList

​	1.7中HashMap和ConcurrentHashMap的源码

​	1.8中HashMap和ConcurrentHashMap的源码





​	主要看put方法、扩容、树化、参数值等方面入手、每个参数的含义是什么、为什么说hashMap是线程不安全的

1 (h = key.hashCode()) ^ (h >>> 16)
    h是int类型，总共32位，意思是，高位也参与运算，减少碰撞次数
1 HashMap的容量为什么是2的次幂
    put数据时，需要根据key来决定存放位置,一般都采用%取模运算来定位位置，即hash(key)%n,当n为2的n次幂时，(n - 1) & hash = hash(key)%n
    还有是扩容的时候，只需要移动部分数据就可以
    比如0101和0001在0011的HashMap中的位置都是0001,当0011扩容到0111之后，0101的位置是0101，就是原来的位置+扩容的大小
    也能说明为什么，N必须是偶数，如果是奇数,N-1最后一位是0，&运算后，最后一位就是0，会浪费空间。
    
    
    
1.奇数不行的解释很能被接受，在计算hash的时候，确定落在数组的位置的时候，计算方法是(n - 1) & hash ，奇数n-1为偶数，偶数2进制的结尾都是0，经过&运算末尾都是0，会 
      增加hash冲突。
   2.为啥要是2的幂，不能是2的倍数么，比如6，10？
       2.1 hashmap 结构是数组，每个数组里面的结构是node（链表或红黑树），正常情况下，如果你想放数据到不同的位置，肯定会想到取余数确定放在那个数据里，  计算公式： 
             hash % n，这个是十进制计算。在计算机中，  (n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n，计算更加高效。
       2.2 只有是2的幂数的数字经过n-1之后，二进制肯定是  ...11111111  这样的格式，这种格式计算的位置的时候（&），完全是由产生的hash值类决定，而不受n-1(组数长度的二进制) 影响。你可能会想，
            受影响不是更好么，又计算了一下，类似于扰动函数，hash冲突可能更低了，这里要考虑到扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相 似,比如
            4和8   00000100    0000 1000   只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算，重新计算采用的方法是key.hash & oldCap == 0在原位置，否则则位移olcCap。
            1.7中，移动链表，是会倒序排列到新链表，所以会有循环指针问题，也就是死锁问题，1.8中是正序排列，没有死锁问题。
    