1 (h = key.hashCode()) ^ (h >>> 16)
    h是int类型，总共32位，意思是，高位也参与运算，减少碰撞次数
1 HashMap的容量为什么是2的次幂
    put数据时，需要根据key来决定存放位置,一般都采用%取模运算来定位位置，即hash(key)%n,当n为2的n次幂时，(n - 1) & hash = hash(key)%n
    还有是扩容的时候，只需要移动部分数据就可以
    比如0101和0001在0011的HashMap中的位置都是0001,当0011扩容到0111之后，0101的位置是0101，就是原来的位置+扩容的大小
    也能说明为什么，N必须是偶数，如果是奇数,N-1最后一位是0，&运算后，最后一位就是0，会浪费空间。
    
    
    
1.奇数不行的解释很能被接受，在计算hash的时候，确定落在数组的位置的时候，计算方法是(n - 1) & hash ，奇数n-1为偶数，偶数2进制的结尾都是0，经过&运算末尾都是0，会 
      增加hash冲突。
   2.为啥要是2的幂，不能是2的倍数么，比如6，10？
       2.1 hashmap 结构是数组，每个数组里面的结构是node（链表或红黑树），正常情况下，如果你想放数据到不同的位置，肯定会想到取余数确定放在那个数据里，  计算公式： 
             hash % n，这个是十进制计算。在计算机中，  (n - 1) & hash，当n为2次幂时，会满足一个公式：(n - 1) & hash = hash % n，计算更加高效。
       2.2 只有是2的幂数的数字经过n-1之后，二进制肯定是  ...11111111  这样的格式，这种格式计算的位置的时候（&），完全是由产生的hash值类决定，而不受n-1(组数长度的二进制) 影响。你可能会想，
            受影响不是更好么，又计算了一下，类似于扰动函数，hash冲突可能更低了，这里要考虑到扩容了，2的幂次方*2，在二进制中比如4和8，代表2的2次方和3次方，他们的2进制结构相 似,比如
            4和8   00000100    0000 1000   只是高位向前移了一位，这样扩容的时候，只需要判断高位hash,移动到之前位置的倍数就可以了，免去了重新计算位置的运算，重新计算采用的方法是key.hash & oldCap == 0在原位置，否则则位移olcCap。
            1.7中，移动链表，是会倒序排列到新链表，所以会有循环指针问题，也就是死锁问题，1.8中是正序排列，没有死锁问题。
    