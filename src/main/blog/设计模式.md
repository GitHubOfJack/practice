设计模式原则（重用性、可读性、可靠性、可维护性）

​	1 单一原则：一个方法、一个类尽量只做一个事情（尽量保证在修改一个功能的时候不会影响别的功能）

​	2 里氏替换原则：所有引用基类的地方必须能透明地使用其子类的对象。子类可以扩展父类的功能，但是不能改变父类原有的功能（不能破坏集成关系）。

​	3 依赖倒置原则：应该是依赖接口编程，而尽量减少依赖具体实现编程。

​	4 接口隔离：类似于单一原则，但是用来约束接口。一个N多个功能的接口可以拆成多个单一功能的接口，用来减少依赖。

​	5 迪米特原则：最少知道原则，一个对象应当对其他对象尽可能少的了解，使得系统功能模块相对独立。低耦合，高内聚。

​	6 开闭原则：对扩展开放，对修改关闭。

高内聚，低耦合：用户模块、账户模块、支付模块（比如用户模块中如果直接修改账户模块数据，同时账户模块也可以修改用户模块数据，这就行相当于低内聚，高耦合。但是如果是用户模块维护用户模块数据，账户模块维护账户模块数据，二者通过接口进行交互，则可以实现，高内聚，低耦合，一个大的系统进行微服务拆分。）

**创建型模式**

1 单例模式

​	饿汉模式-浪费空间

​	懒汉模式-线程安全问题

​	DCL单例-必须有volatile关键字+双重锁

​	内部类实现单例-可以被反射生成和序列化问题

​	枚举单例-可以解决反射和反序列化问题

2 工厂模式（BeanFactory\FactoryBean）

​	工厂方法

​	抽象工厂

9 建造者模式（复杂对象的构建，比如一个对象有N多个属性，会有多种组合方式产生多种对象。可以采用建造者模式，根据需求定制产品。链式编程，实际例子，StringBuilder）

15 原型模式-复制对象（参考clone方法，会引入深copy和浅copy的问题）

**结构型模式**

5 适配器模式（spring中的AOP使用了适配器模式）

8 桥建模式（两个分支，通过桥梁连接）

14 组合模式（用来处理树状结构的模式）

10 装饰模式（）

7 代理模式

​	静态代理

​	动态代理

13 享元模式（对比对象池模式，享元模式可以只不同对象存在一个地方，而对象池技术是，池中的对象都是一样的，取那个都行）

11 门面模式-调停者模式（对外是门面模式，对内是调停者模式）

**行为型模式**

3 策略模式（一个接口，多个实现类，可以自由切换多个实现类，可以实现算法的定义和算法的使用分来）

4 责任链模式（spring中的AOP使用了责任链模式）

6 观察者模式（监听模式、钩子函数、回调函数,spring中的各种listener）

12 模板模式（类比策略模式：模板模式的调用者是调用的基类中的方法，由基类方法来控制整个流程的运行。典型的是JUC中AQS的acquire方法的实现）









